{
  "name": "Notion Agent - Standalone Test",
  "nodes": [
    {
      "parameters": {},
      "id": "manual-trigger",
      "name": "Manual Test Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [240, 300]
    },
    {
      "parameters": {
        "httpMethod": "GET",
        "path": "notion-agent-health",
        "options": {}
      },
      "id": "webhook-health",
      "name": "Webhook Health Check",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 180]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "notion-agent-execute",
        "options": {}
      },
      "id": "webhook-execute",
      "name": "Webhook Execute",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 420]
    },
    {
      "parameters": {
        "httpMethod": "GET",
        "path": "notion-agent-status",
        "options": {}
      },
      "id": "webhook-status",
      "name": "Webhook Status",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 540]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "health-response",
              "name": "healthResponse",
              "value": {
                "agent_id": "notion",
                "status": "healthy",
                "timestamp": "={{ new Date().toISOString() }}",
                "services": {
                  "mcp_tools": "active",
                  "notion_api": "active", 
                  "database_access": "active"
                },
                "capabilities": [
                  "get_ideas",
                  "search_ideas", 
                  "update_idea",
                  "multi_idea_parsing",
                  "categorization"
                ],
                "last_activity": "={{ new Date().toISOString() }}",
                "version": "1.0.0"
              },
              "type": "object"
            }
          ]
        }
      },
      "id": "health-response",
      "name": "Health Response",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [460, 180]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json.healthResponse) }}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      },
      "id": "health-webhook-response",
      "name": "Health Webhook Response",  
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [680, 180]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "status-response",
              "name": "statusResponse",
              "value": {
                "agent_id": "notion",
                "current_status": "ready",
                "timestamp": "={{ new Date().toISOString() }}",
                "active_tasks": 0,
                "total_executions": "{{ Math.floor(Math.random() * 100) }}",
                "last_execution": "={{ new Date(Date.now() - Math.floor(Math.random() * 3600000)).toISOString() }}",
                "performance": {
                  "avg_response_time_ms": "{{ Math.floor(Math.random() * 2000) + 500 }}",
                  "success_rate": 0.95,
                  "cache_hit_rate": 0.78
                }
              },
              "type": "object"
            }
          ]
        }
      },
      "id": "status-response",
      "name": "Status Response",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [460, 540]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json.statusResponse) }}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      },
      "id": "status-webhook-response",
      "name": "Status Webhook Response",  
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [680, 540]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "test-context",
              "name": "testContext",
              "value": {
                "sessionId": "={{ $now.toISOString() }}",
                "workflowType": "notion_agent_test",
                "startTime": "={{ new Date().toISOString() }}",
                "agentType": "notion",
                "instruction": {
                  "task_type": "multi_idea_categorization",
                  "objective": "Parse content for multiple distinct ideas and categorize each into appropriate target databases",
                  "source_database_id": "16cd7be3dbcd80e1aac9c3a95ffaa61a",
                  "limit": 1,
                  "status_filter": "Not Started"
                },
                "categorization_methodology": {
                  "multi_idea_parsing_rules": [
                    "Paragraph Separation: Each paragraph may contain a distinct idea",
                    "Empty Block Delimiter: Extra empty blocks separate ideas", 
                    "Link + Description Grouping: Text above links describes that link",
                    "Topic Shift Detection: Identify complete topic changes",
                    "Context Preservation: Maintain original meaning and intent"
                  ],
                  "database_routing_criteria": {
                    "projects": {
                      "database_id": "3cd8ea052d6d4b69956e89b1184cae75",
                      "description": "Actionable tasks, implementations, things to build or execute",
                      "keywords": ["build", "create", "implement", "develop", "task", "action"],
                      "criteria": "actionable_items",
                      "examples": ["Build Todo App", "Create automation script", "Implement feature X"]
                    },
                    "knowledge": {
                      "database_id": "263d7be3dbcd80c0b6e4fd309a8af453", 
                      "description": "Reference materials, articles, videos, educational content",
                      "keywords": ["article", "video", "reference", "learn", "tutorial", "guide"],
                      "criteria": "reference_materials",
                      "examples": ["Interesting article about AI", "Tutorial video", "Research paper"]
                    },
                    "journal": {
                      "database_id": "a1d35f6081a044589425512cb9d136b7",
                      "description": "Personal thoughts, reflections, observations, insights",
                      "keywords": ["thought", "reflection", "personal", "opinion", "insight"],
                      "criteria": "personal_insights", 
                      "examples": ["My thoughts on...", "Personal reflection", "Opinion about..."]
                    }
                  },
                  "tagging_rules": {
                    "max_tags": 3,
                    "predefined_only": true,
                    "available_tags": ["Priority", "Notion Template", "Brand", "Content Creator", "Music", "Funny", "Coding", "App", "Educational", "Gaming", "AI", "Monetize", "Social Media", "Thought", "Niche", "Project Hub", "Automation", "Project", "Database"],
                    "selection_criteria": "Choose tags that best describe content type, domain, or purpose - most relevant first"
                  },
                  "analysis_requirements": {
                    "assess_actionability": "Determine if idea requires action (Yes/No)",
                    "evaluate_reference_value": "Rate reference value (High/Medium/Low)",
                    "identify_personal_insight": "Check if contains personal thoughts (Yes/No)",
                    "assign_priority": "Set priority level (High/Medium/Low)",
                    "provide_reasoning": "Explain categorization decision in 1-2 sentences"
                  }
                },
                "execution_requirements": {
                  "required_tools": ["get_ideas", "get_idea_by_id"],
                  "timeout_seconds": 180,
                  "response_format": "categorization_results_json",
                  "processing_approach": "Parse each retrieved idea for multiple concepts, apply categorization rules to each parsed idea, return structured analysis"
                },
                "task_id": "cat_test_001",
                "testMode": true
              },
              "type": "object"
            }
          ]
        },
        "options": {}
      },
      "id": "setup-context",
      "name": "Setup Test Context",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [460, 300]
    },
    {
      "parameters": {
        "toolDescription": "TESTING: Get exactly 1 idea only. ALWAYS use limit=1 and status='Not Started'. Do not exceed 1 idea to control token usage.",
        "method": "GET",
        "url": "http://host.docker.internal:3001/api/ideas?limit={limit}&filter={filter}&status={status}&daysBack={daysBack}",
        "placeholderDefinitions": {
          "values": [
            {
              "name": "limit",
              "description": "TESTING: Always use 1 to get exactly one idea"
            },
            {
              "name": "filter",
              "description": "Optional text search filter"
            },
            {
              "name": "status",
              "description": "Status filter: 'Not Started', 'In Progress', 'Done'"
            },
            {
              "name": "daysBack",
              "description": "Filter recent ideas (7 = this week, 1 = today)"
            }
          ]
        }
      },
      "id": "get-ideas-tool",
      "name": "Notion Get Ideas",
      "type": "@n8n/n8n-nodes-langchain.toolHttpRequest",
      "typeVersion": 1.1,
      "position": [700, 200]
    },
    {
      "parameters": {
        "toolDescription": "Get specific idea by ID for detailed analysis",
        "method": "GET",
        "url": "http://host.docker.internal:3001/api/ideas/{idea_id}",
        "placeholderDefinitions": {
          "values": [
            {
              "name": "idea_id",
              "description": "The ID of the specific idea to retrieve"
            }
          ]
        }
      },
      "id": "get-idea-by-id-tool",
      "name": "Notion Get Idea By ID",
      "type": "@n8n/n8n-nodes-langchain.toolHttpRequest",
      "typeVersion": 1.1,
      "position": [700, 300]
    },
    {
      "parameters": {
        "toolDescription": "Search ideas by content or title",
        "method": "POST",
        "url": "http://host.docker.internal:3001/api/ideas/search",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ {\n  \"query\": \"{query}\",\n  \"limit\": {limit}\n} }}",
        "placeholderDefinitions": {
          "values": [
            {
              "name": "query",
              "description": "Search query to find matching ideas"
            },
            {
              "name": "limit",
              "description": "Number of results (default: 20)"
            }
          ]
        }
      },
      "id": "search-ideas-tool",
      "name": "Notion Search Ideas",
      "type": "@n8n/n8n-nodes-langchain.toolHttpRequest",
      "typeVersion": 1.1,
      "position": [700, 400]
    },
    {
      "parameters": {
        "toolDescription": "Update idea status - simplified for testing. REQUIRED: Always provide status parameter. Use 'In Progress' or 'Done'.",
        "method": "PUT",
        "url": "http://host.docker.internal:3001/api/ideas/{idea_id}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ {\"status\": \"{status}\"} }}",
        "placeholderDefinitions": {
          "values": [
            {
              "name": "idea_id",
              "description": "ID of idea to update"
            },
            {
              "name": "status",
              "description": "REQUIRED: Use 'Not Started', 'In Progress', or 'Done'"
            }
          ]
        }
      },
      "id": "update-idea-tool",
      "name": "Notion Update Idea",
      "type": "@n8n/n8n-nodes-langchain.toolHttpRequest",
      "typeVersion": 1.1,
      "position": [700, 500]
    },
    {
      "parameters": {
        "toolDescription": "Get schema and property information for any database to understand its structure",
        "method": "GET",
        "url": "http://host.docker.internal:3001/api/databases/{database_id}/schema",
        "placeholderDefinitions": {
          "values": [
            {
              "name": "database_id",
              "description": "The Notion database ID to get schema for"
            }
          ]
        }
      },
      "id": "get-database-schema-tool",
      "name": "Get Database Schema",
      "type": "@n8n/n8n-nodes-langchain.toolHttpRequest",
      "typeVersion": 1.1,
      "position": [700, 600]
    },
    {
      "parameters": {
        "toolDescription": "Get all pages from any database with filtering options",
        "method": "GET",
        "url": "http://host.docker.internal:3001/api/databases/{database_id}/pages?limit={limit}&filter={filter}&status={status}&daysBack={daysBack}",
        "placeholderDefinitions": {
          "values": [
            {
              "name": "database_id",
              "description": "The Notion database ID to query"
            },
            {
              "name": "limit",
              "description": "Maximum number of pages to retrieve (default: 50)"
            },
            {
              "name": "filter",
              "description": "Optional text search filter"
            },
            {
              "name": "status",
              "description": "Optional status filter"
            },
            {
              "name": "daysBack",
              "description": "Filter by recent edits (7 = this week, 1 = today)"
            }
          ]
        }
      },
      "id": "get-database-pages-tool",
      "name": "Get Database Pages",
      "type": "@n8n/n8n-nodes-langchain.toolHttpRequest",
      "typeVersion": 1.1,
      "position": [700, 700]
    },
    {
      "parameters": {
        "toolDescription": "Update or create a page in any database with flexible properties",
        "method": "PUT",
        "url": "http://host.docker.internal:3001/api/databases/{database_id}/pages/{page_id}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ {properties} }}",
        "placeholderDefinitions": {
          "values": [
            {
              "name": "database_id",
              "description": "The target database ID"
            },
            {
              "name": "page_id",
              "description": "The page ID to update (use 'new' to create new page)"
            },
            {
              "name": "properties",
              "description": "JSON object with properties to update based on database schema"
            }
          ]
        }
      },
      "id": "update-database-page-tool",
      "name": "Update Database Page",
      "type": "@n8n/n8n-nodes-langchain.toolHttpRequest",
      "typeVersion": 1.1,
      "position": [700, 800]
    },
    {
      "parameters": {
        "toolDescription": "Auto-detect optimal property mappings for a database",
        "method": "GET",
        "url": "http://host.docker.internal:3001/api/databases/{database_id}/auto-config",
        "placeholderDefinitions": {
          "values": [
            {
              "name": "database_id",
              "description": "The database ID to analyze for property mappings"
            }
          ]
        }
      },
      "id": "auto-config-database-tool",
      "name": "Auto-Config Database",
      "type": "@n8n/n8n-nodes-langchain.toolHttpRequest",
      "typeVersion": 1.1,
      "position": [700, 900]
    },
    {
      "parameters": {
        "jsCode": "// Generic Director Instructions Parser\n// Converts JSON instructions from Director into readable text for LLM\n\nconst directorInstructions = $json.testContext || $json;\n\n// Extract task type and format dynamically\nconst taskType = directorInstructions.instruction?.task_type || 'unknown_task';\nconst taskTitle = taskType.replace(/_/g, ' ').toUpperCase();\n\n// Generic instruction builder\nfunction buildInstructionText(instructions) {\n  let text = `${taskTitle}\\n\\n`;\n  \n  // Core instruction section (always present)\n  if (instructions.instruction?.objective) {\n    text += `OBJECTIVE: ${instructions.instruction.objective}\\n\\n`;\n  }\n  \n  // Dynamic sections based on what's present in JSON\n  if (instructions.instruction?.source_database_id) {\n    text += `SOURCE DATABASE:\\n`;\n    text += `• Database ID: ${instructions.instruction.source_database_id}\\n`;\n    if (instructions.instruction.limit) text += `• Limit: ${instructions.instruction.limit}\\n`;\n    if (instructions.instruction.status_filter) text += `• Status Filter: ${instructions.instruction.status_filter}\\n`;\n    text += `\\n`;\n  }\n  \n  // Categorization methodology (for categorization tasks)\n  if (instructions.categorization_methodology) {\n    text += buildCategorizationSection(instructions.categorization_methodology);\n  }\n  \n  // Database execution instructions (for update tasks)\n  if (instructions.database_execution) {\n    text += buildDatabaseExecutionSection(instructions.database_execution);\n  }\n  \n  // Content processing rules (for content tasks)\n  if (instructions.content_processing) {\n    text += buildContentProcessingSection(instructions.content_processing);\n  }\n  \n  // Execution requirements (always present)\n  if (instructions.execution_requirements) {\n    text += `EXECUTION REQUIREMENTS:\\n`;\n    if (instructions.execution_requirements.required_tools) {\n      text += `• Required Tools: ${instructions.execution_requirements.required_tools.join(', ')}\\n`;\n    }\n    if (instructions.execution_requirements.timeout_seconds) {\n      text += `• Timeout: ${instructions.execution_requirements.timeout_seconds} seconds\\n`;\n    }\n    if (instructions.execution_requirements.response_format) {\n      text += `• Response Format: ${instructions.execution_requirements.response_format}\\n`;\n    }\n    if (instructions.execution_requirements.processing_approach) {\n      text += `• Processing Approach: ${instructions.execution_requirements.processing_approach}\\n`;\n    }\n    text += `\\n`;\n  }\n  \n  return text;\n}\n\n// Helper functions for different section types\nfunction buildCategorizationSection(methodology) {\n  let text = `MULTI-IDEA PARSING RULES:\\n`;\n  if (methodology.multi_idea_parsing_rules) {\n    methodology.multi_idea_parsing_rules.forEach(rule => {\n      text += `• ${rule}\\n`;\n    });\n    text += `\\n`;\n  }\n  \n  if (methodology.database_routing_criteria) {\n    text += `DATABASE ROUTING CRITERIA:\\n\\n`;\n    Object.entries(methodology.database_routing_criteria).forEach(([dbType, criteria]) => {\n      text += `${dbType.toUpperCase()} DATABASE (${criteria.database_id}):\\n`;\n      text += `• Description: ${criteria.description}\\n`;\n      if (criteria.keywords) text += `• Keywords: ${criteria.keywords.join(', ')}\\n`;\n      if (criteria.examples) text += `• Examples: ${criteria.examples.join(', ')}\\n`;\n      text += `\\n`;\n    });\n  }\n  \n  if (methodology.tagging_rules) {\n    text += `TAGGING RULES:\\n`;\n    text += `• Maximum Tags: ${methodology.tagging_rules.max_tags}\\n`;\n    if (methodology.tagging_rules.available_tags) {\n      text += `• Available Tags: ${methodology.tagging_rules.available_tags.join(', ')}\\n`;\n    }\n    if (methodology.tagging_rules.selection_criteria) {\n      text += `• Selection Criteria: ${methodology.tagging_rules.selection_criteria}\\n`;\n    }\n    text += `\\n`;\n  }\n  \n  if (methodology.analysis_requirements) {\n    text += `ANALYSIS REQUIREMENTS:\\n`;\n    Object.entries(methodology.analysis_requirements).forEach(([key, value]) => {\n      text += `• ${key.replace(/_/g, ' ')}: ${value}\\n`;\n    });\n    text += `\\n`;\n  }\n  \n  return text;\n}\n\nfunction buildDatabaseExecutionSection(execution) {\n  let text = `DATABASE EXECUTION INSTRUCTIONS:\\n\\n`;\n  \n  if (execution.operations) {\n    text += `OPERATIONS TO PERFORM:\\n`;\n    execution.operations.forEach((op, index) => {\n      text += `${index + 1}. ${op.action.toUpperCase()}\\n`;\n      text += `   • Target Database: ${op.target_database_id}\\n`;\n      text += `   • Page ID: ${op.page_id || 'new'}\\n`;\n      if (op.properties) {\n        text += `   • Properties to Update:\\n`;\n        Object.entries(op.properties).forEach(([key, value]) => {\n          text += `     - ${key}: ${value}\\n`;\n        });\n      }\n      text += `\\n`;\n    });\n  }\n  \n  if (execution.validation_rules) {\n    text += `VALIDATION RULES:\\n`;\n    Object.entries(execution.validation_rules).forEach(([key, value]) => {\n      text += `• ${key.replace(/_/g, ' ')}: ${value}\\n`;\n    });\n    text += `\\n`;\n  }\n  \n  return text;\n}\n\nfunction buildContentProcessingSection(processing) {\n  let text = `CONTENT PROCESSING RULES:\\n`;\n  \n  if (processing.parsing_rules) {\n    processing.parsing_rules.forEach(rule => {\n      text += `• ${rule}\\n`;\n    });\n    text += `\\n`;\n  }\n  \n  if (processing.transformation_rules) {\n    text += `TRANSFORMATION RULES:\\n`;\n    processing.transformation_rules.forEach(rule => {\n      text += `• ${rule}\\n`;\n    });\n    text += `\\n`;\n  }\n  \n  return text;\n}\n\n// Build the instruction text\nconst instructionText = buildInstructionText(directorInstructions);\n\n// For backwards compatibility with current test format\nconst testContext = directorInstructions.testContext || directorInstructions;\n\n// Return parsed data\nreturn [{ \n  instructionText, \n  originalJSON: directorInstructions,\n  taskType: directorInstructions.instruction?.task_type || 'test_task',\n  testContext: testContext // Maintain compatibility\n}];"
      },
      "id": "parse-director-instructions",
      "name": "Parse Director Instructions",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [500, 400]
    },
    {
      "parameters": {
        "model": "gpt-4o-mini",
        "options": {
          "temperature": 0.3,
          "maxTokens": 4000
        }
      },
      "id": "gpt-model",
      "name": "GPT-4o Mini Notion Model",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1,
      "position": [680, 700],
      "credentials": {
        "openAiApi": {
          "id": "1",
          "name": "OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "{{ $json.instructionText }}",
        "hasOutputParser": false,
        "agent": "toolsAgent",
        "options": {
          "systemMessage": "You are the Notion Agent executing Director instructions.\n\n# EXECUTION APPROACH\n1. Read the task objective and requirements carefully\n2. Use the provided methodology and rules to execute the task\n3. Apply all specified validation and processing rules\n4. Use the required MCP tools as instructed\n5. Return results in the specified JSON format\n\n# RESPONSE FORMAT\nReturn ONLY JSON in this exact structure:\n{\n  \"agent_id\": \"notion\",\n  \"task_id\": \"{{ $json.originalJSON.task_id || 'test_task' }}\",\n  \"phase\": \"{{ $json.taskType }}_complete\",\n  \"timestamp\": \"ISO_timestamp\",\n  \"execution_time_ms\": number,\n  \"results\": {\n    // Task-specific results based on task type\n    // For categorization: ideas_processed array with categorization analysis\n    // For database_updates: operations_completed array with success/failure status\n    // For content_processing: processed_content with transformations applied\n  },\n  \"status\": {\n    \"success\": boolean,\n    \"errors\": [],\n    \"next_phase\": \"string\"\n  },\n  \"context_updates\": {\n    \"api_calls\": number,\n    \"tools_used\": [],\n    \"performance_notes\": \"string\"\n  }\n}\n\n**CRITICAL: Output only valid JSON. No explanations or summaries. Focus solely on the task described in the instructions.**",
          "maxIterations": 10
        }
      },
      "id": "notion-agent",
      "name": "Notion Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.6,
      "position": [680, 300]
    },
    {
      "parameters": {
        "jsCode": "// Analyze Notion Agent Test Results\nconst notionOutput = $json;\nconst testContext = $('Setup Test Context').first().json.testContext;\n\n// Extract output text\nconst outputText = notionOutput.output || notionOutput.text || JSON.stringify(notionOutput) || '';\n\n// Analyze tool usage with improved detection\nconst toolUsageAnalysis = {\n  usedGetIdeas: outputText.includes('get_ideas') || outputText.toLowerCase().includes('retrieved idea') || outputText.toLowerCase().includes('retrieved ideas') || outputText.toLowerCase().includes('the retrieved'),\n  usedGetById: outputText.includes('get_idea_by_id') || outputText.toLowerCase().includes('analyzed idea') || outputText.toLowerCase().includes('detailed analysis') || outputText.toLowerCase().includes('idea titled'),\n  usedSearch: outputText.includes('search_ideas') || outputText.toLowerCase().includes('searched') || outputText.toLowerCase().includes('search'),\n  usedUpdate: outputText.includes('update_idea') || outputText.toLowerCase().includes('updated') || outputText.toLowerCase().includes('updating') || outputText.toLowerCase().includes('update the status') || outputText.toLowerCase().includes('status to \"done\"'),\n  mentionedStatus: outputText.toLowerCase().includes('not started') || outputText.toLowerCase().includes('in progress') || outputText.toLowerCase().includes('done') || outputText.toLowerCase().includes('status'),\n  mentionedMultiIdea: outputText.toLowerCase().includes('multi') || outputText.toLowerCase().includes('parsing') || outputText.toLowerCase().includes('multiple distinct ideas') || outputText.toLowerCase().includes('idea 1') || outputText.toLowerCase().includes('idea #'),\n  mentionedCategorization: outputText.toLowerCase().includes('project') || outputText.toLowerCase().includes('journal') || outputText.toLowerCase().includes('knowledge archive') || outputText.toLowerCase().includes('database')\n};\n\n// Calculate success metrics\nconst toolsUsed = Object.values(toolUsageAnalysis).filter(Boolean).length;\nconst hasStructuredOutput = outputText.length > 100;\nconst hasNotionFocus = outputText.toLowerCase().includes('notion') || outputText.toLowerCase().includes('idea');\n\n// Determine test status\nconst testStatus = {\n  toolUsageScore: toolsUsed,\n  maxToolScore: Object.keys(toolUsageAnalysis).length,\n  hasStructuredOutput,\n  hasNotionFocus,\n  overallScore: (toolsUsed / Object.keys(toolUsageAnalysis).length) * 100\n};\n\nconst testResults = {\n  timestamp: new Date().toISOString(),\n  testType: 'Notion Agent Standalone',\n  testContext,\n  toolUsageAnalysis,\n  testStatus,\n  outputText,\n  summary: {\n    status: testStatus.overallScore >= 50 && hasStructuredOutput ? 'PASSED' : 'FAILED',\n    score: Math.round(testStatus.overallScore),\n    toolsUsed: toolsUsed,\n    hasNotionExpertise: hasNotionFocus\n  }\n};\n\nreturn [testResults];"
      },
      "id": "analyze-results",
      "name": "Analyze Test Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "combinator": "and",
          "conditions": [
            {
              "operator": {
                "type": "string",
                "operation": "equals"
              },
              "leftValue": "={{ $json.summary.status }}",
              "rightValue": "PASSED"
            }
          ]
        },
        "options": {}
      },
      "id": "test-result-switch",
      "name": "Test Result Switch",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3,
      "position": [1120, 300]
    },
    {
      "parameters": {
        "jsCode": "// SUCCESS: Notion Agent Test Passed\nconst results = $json;\n\nreturn [{\n  status: 'SUCCESS',\n  message: '✅ Notion Agent Test PASSED',\n  details: {\n    score: results.summary.score + '%',\n    toolsUsed: results.summary.toolsUsed + '/' + results.testStatus.maxToolScore,\n    hasStructuredOutput: results.testStatus.hasStructuredOutput,\n    hasNotionExpertise: results.summary.hasNotionExpertise,\n    toolUsage: results.toolUsageAnalysis\n  },\n  analysis: {\n    strengths: [\n      results.toolUsageAnalysis.usedGetIdeas ? 'Successfully used get_ideas tool' : null,\n      results.toolUsageAnalysis.usedGetById ? 'Used get_idea_by_id for analysis' : null,\n      results.toolUsageAnalysis.mentionedStatus ? 'Understands status workflow' : null,\n      results.toolUsageAnalysis.mentionedMultiIdea ? 'Aware of multi-idea parsing' : null\n    ].filter(Boolean),\n    areas_for_improvement: [\n      !results.toolUsageAnalysis.usedUpdate ? 'Could use update_idea tool more' : null,\n      !results.toolUsageAnalysis.mentionedCategorization ? 'Could improve categorization logic' : null\n    ].filter(Boolean)\n  },\n  nextSteps: [\n    'Notion Agent is working with MCP tools',\n    'Ready to integrate with Director routing',\n    'Can handle idea processing tasks'\n  ],\n  timestamp: results.timestamp\n}];"
      },
      "id": "success-output",
      "name": "✅ Test Success",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1320, 200]
    },
    {
      "parameters": {
        "jsCode": "// FAILURE: Notion Agent Test Failed\nconst results = $json;\n\nreturn [{\n  status: 'FAILURE',\n  message: '❌ Notion Agent Test FAILED',\n  details: {\n    score: results.summary.score + '%',\n    toolsUsed: results.summary.toolsUsed + '/' + results.testStatus.maxToolScore,\n    hasStructuredOutput: results.testStatus.hasStructuredOutput,\n    toolUsage: results.toolUsageAnalysis\n  },\n  issues: [\n    results.summary.score < 30 ? 'Very low tool usage - check MCP server connection' : null,\n    !results.testStatus.hasStructuredOutput ? 'Agent output too brief or empty' : null,\n    !results.summary.hasNotionExpertise ? 'Agent not demonstrating Notion expertise' : null,\n    !results.toolUsageAnalysis.usedGetIdeas ? 'Failed to use basic get_ideas tool' : null\n  ].filter(Boolean),\n  troubleshooting: [\n    'Check MCP server is running on port 3001',\n    'Verify notion-idea-server is accessible',\n    'Test API endpoints manually: curl http://localhost:3001/api/ideas',\n    'Check agent system message and tool configurations',\n    'Verify Claude API credentials'\n  ],\n  rawOutput: results.outputText.substring(0, 500) + '...',\n  timestamp: results.timestamp\n}];"
      },
      "id": "failure-output",
      "name": "❌ Test Failure",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1320, 400]
    }
  ],
  "connections": {
    "Manual Test Trigger": {
      "main": [
        [
          {
            "node": "Setup Test Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook Health Check": {
      "main": [
        [
          {
            "node": "Health Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Health Response": {
      "main": [
        [
          {
            "node": "Health Webhook Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook Execute": {
      "main": [
        [
          {
            "node": "Parse Director Instructions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook Status": {
      "main": [
        [
          {
            "node": "Status Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Status Response": {
      "main": [
        [
          {
            "node": "Status Webhook Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Setup Test Context": {
      "main": [
        [
          {
            "node": "Parse Director Instructions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Director Instructions": {
      "main": [
        [
          {
            "node": "Notion Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Notion Get Ideas": {
      "ai_tool": [
        [
          {
            "node": "Notion Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Notion Get Idea By ID": {
      "ai_tool": [
        [
          {
            "node": "Notion Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Notion Search Ideas": {
      "ai_tool": [
        [
          {
            "node": "Notion Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Notion Update Idea": {
      "ai_tool": [
        [
          {
            "node": "Notion Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Get Database Schema": {
      "ai_tool": [
        [
          {
            "node": "Notion Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Get Database Pages": {
      "ai_tool": [
        [
          {
            "node": "Notion Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Update Database Page": {
      "ai_tool": [
        [
          {
            "node": "Notion Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Auto-Config Database": {
      "ai_tool": [
        [
          {
            "node": "Notion Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "GPT-4o Mini Notion Model": {
      "ai_languageModel": [
        [
          {
            "node": "Notion Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Notion Agent": {
      "main": [
        [
          {
            "node": "Analyze Test Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Analyze Test Results": {
      "main": [
        [
          {
            "node": "Test Result Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Test Result Switch": {
      "main": [
        [
          {
            "node": "✅ Test Success",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "❌ Test Failure",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2025-01-15T09:00:00.000Z",
  "versionId": "test-notion-v1"
} 